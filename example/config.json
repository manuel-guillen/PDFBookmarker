{
	"labelRanges": [ {"start": 1, "style": "None", "prefix": "Cover"},
					 {"start": 2, "style": "Lowercase Roman Numerals", "prefix": ""},
					 {"start": 24, "style": "Decimal Arabic Numerals", "prefix": ""}
				   ],
	"bookmarks": [ {"name": "Contents", "page": 8, "children": []},
				   {"name": "Forward to the First Edition", "page": 18, "children": []},
				   {"name": "Preface", "page": 20, "children": []},
				   {"name": "About the Author", "page": 22, "children": []},
				   {"name": "Chapter 1: The Basics", "page": 23, "children": [
				   		{"name": "1.1 The Scala Interpreter", "page": 24, "children": []},
				   		{"name": "1.2 Declaring Values and Variables", "page": 27, "children": []},
				   		{"name": "1.3 Commonly Used Types", "page": 28, "children": []},
				   		{"name": "1.4 Arithmetic and Operator Overloading", "page": 29, "children": []},
				   		{"name": "1.5 More about Calling Methods", "page": 31, "children": []},
				   		{"name": "1.6 The apply Method", "page": 32, "children": []},
				   		{"name": "1.7 Scaladoc", "page": 33, "children": []},
				   		{"name": "Exercises", "page": 38, "children": []}
				   		]},
				   {"name": "Chapter 2: Control Structures and Functions", "page": 39, "children": [
				   		{"name": "2.1 Conditional Expressions", "page": 41, "children": []},
				   		{"name": "2.2 Statement Termination", "page": 42, "children": []},
				   		{"name": "2.3 Block Expressions and Assignments", "page": 43, "children": []},
				   		{"name": "2.4 Input and Output", "page": 44, "children": []},
				   		{"name": "2.5 Loops", "page": 45, "children": []},
				   		{"name": "2.6 Advanced for Loops", "page": 47, "children": []},
				   		{"name": "2.7 Functions", "page": 48, "children": []},
				   		{"name": "2.8 Default and Named Arguments", "page": 49, "children": []},
				   		{"name": "2.9 Variable Arguments", "page": 49, "children": []},
				   		{"name": "2.10 Procedures", "page": 51, "children": []},
				   		{"name": "2.11 Lazy Values", "page": 51, "children": []},
				   		{"name": "2.12 Exceptions", "page": 52, "children": []},
				   		{"name": "Exercises", "page": 54, "children": []}
				   		]},
				   {"name": "Chapter 3: Working with Arrays", "page": 57, "children": [
				   		{"name": "3.1 Fixed-Length Arrays", "page": 58, "children": []},
				   		{"name": "3.2 Variable-Length Arrays: Array Buffers", "page": 59, "children": []},
				   		{"name": "3.3 Traversing Arrays and Array Buffers", "page": 60, "children": []},
				   		{"name": "3.4 Transforming Arrays", "page": 61, "children": []},
				   		{"name": "3.5 Common Algorithms", "page": 63, "children": []},
				   		{"name": "3.6 Deciphering Scaladoc", "page": 64, "children": []},
				   		{"name": "3.7 Multidimensional Arrays", "page": 65, "children": []},
				   		{"name": "3.8 Interoperating with Java", "page": 66, "children": []},
				   		{"name": "Exercises", "page": 67, "children": []}
				   		]},
				   {"name": "Chapter 4: Maps and Tuples", "page": 69, "children": [
				   		{"name": "4.1 Constructing a Map", "page": 71, "children": []},
				   		{"name": "4.2 Accessing Map Values", "page": 71, "children": []},
				   		{"name": "4.3 Updating Map Values", "page": 72, "children": []},
				   		{"name": "4.4 Iterating over Maps", "page": 73, "children": []},
				   		{"name": "4.5 Sorted Maps", "page": 73, "children": []},
				   		{"name": "4.6 Interoperating with Java", "page": 73, "children": []},
				   		{"name": "4.7 Tuples", "page": 74, "children": []},
				   		{"name": "4.8 Zipping", "page": 75, "children": []},
				   		{"name": "Exercises", "page": 75, "children": []}
				   		]},
				   {"name": "Chapter 5: Classes", "page": 77, "children": [
				   		{"name": "5.1 Simple Classes and Parameterless Methods", "page": 78, "children": []},
				   		{"name": "5.2 Properties with Getters and Setters", "page": 79, "children": []},
				   		{"name": "5.3 Properties with Only Getters", "page": 82, "children": []},
				   		{"name": "5.4 Object-Private Fields", "page": 83, "children": []},
				   		{"name": "5.5 Bean Properties", "page": 84, "children": []},
				   		{"name": "5.6 Auxiliary Constructors", "page": 85, "children": []},
				   		{"name": "5.7 The Primary Constructor", "page": 86, "children": []},
				   		{"name": "5.8 Nested Classes", "page": 89, "children": []},
				   		{"name": "Exercises", "page": 91, "children": []}
				   		]},
				   {"name": "Chapter 6: Objects", "page": 93, "children": [
				   		{"name": "6.1 Singletons", "page": 94, "children": []},
				   		{"name": "6.2 Companion Objects", "page": 95, "children": []},
				   		{"name": "6.3 Objects Extending a Class or Trait", "page": 96, "children": []},
				   		{"name": "6.4 The apply Method", "page": 96, "children": []},
				   		{"name": "6.5 Application Objects", "page": 97, "children": []},
				   		{"name": "6.6 Enumerations", "page": 98, "children": []},
				   		{"name": "Exercises", "page": 100, "children": []}
				   		]},
				   {"name": "Chapter 7: Packages and Imports", "page": 101, "children": [
				   		{"name": "7.1 Packages", "page": 103, "children": []},
				   		{"name": "7.2 Scope Rules", "page": 104, "children": []},
				   		{"name": "7.3 Chained Package Clauses", "page": 106, "children": []},
				   		{"name": "7.4 Top-of-File Notation", "page": 106, "children": []},
				   		{"name": "7.5 Package Objects", "page": 106, "children": []},
				   		{"name": "7.6 Package Visibility", "page": 107, "children": []},
				   		{"name": "7.7 Imports", "page": 108, "children": []},
				   		{"name": "7.8 Imports Can Be Anywhere", "page": 108, "children": []},
				   		{"name": "7.9 Renaming and Hiding Members", "page": 109, "children": []},
				   		{"name": "7.10 Implicit Imports", "page": 109, "children": []},
				   		{"name": "Exercises", "page": 110, "children": []}
				   		]},
				   {"name": "Chapter 8: Inheritance", "page": 113, "children": [
				   		{"name": "8.1 Extending a Class", "page": 114, "children": []},
				   		{"name": "8.2 Overriding Methods", "page": 115, "children": []},
				   		{"name": "8.3 Type Checks and Casts", "page": 116, "children": []},
				   		{"name": "8.4 Protected Fields and Methods", "page": 117, "children": []},
				   		{"name": "8.5 Superclass Construction", "page": 117, "children": []},
				   		{"name": "8.6 Overriding Fields", "page": 118, "children": []},
				   		{"name": "8.7 Anonymous Subclasses", "page": 120, "children": []},
				   		{"name": "8.8 Abstract Classes", "page": 120, "children": []},
				   		{"name": "8.9 Abstract Fields", "page": 120, "children": []},
				   		{"name": "8.10 Construction Order and Early Definitions", "page": 121, "children": []},
				   		{"name": "8.11 The Scala Inheritance Hierarchy", "page": 123, "children": []},
				   		{"name": "8.12 Object Equality", "page": 125, "children": []},
				   		{"name": "8.13 Value Classes", "page": 126, "children": []},
				   		{"name": "Exercises", "page": 128, "children": []}
				   		]},
				   {"name": "Chapter 9: Files and Regular Expressions", "page": 131, "children": [
				   		{"name": "9.1 Reading Lines", "page": 132, "children": []},
				   		{"name": "9.2 Reading Characters", "page": 133, "children": []},
				   		{"name": "9.3 Reading Tokens and Numbers", "page": 134, "children": []},
				   		{"name": "9.4 Reading from URLs and Other Sources", "page": 134, "children": []},
				   		{"name": "9.5 Reading Binary Files", "page": 135, "children": []},
				   		{"name": "9.6 Writing Text Files", "page": 135, "children": []},
				   		{"name": "9.7 Visiting Directories", "page": 135, "children": []},
				   		{"name": "9.8 Serialization", "page": 136, "children": []},
				   		{"name": "9.9 Process Control", "page": 137, "children": []},
				   		{"name": "9.10 Regular Expressions", "page": 139, "children": []},
				   		{"name": "9.11 Regular Expression Groups", "page": 140, "children": []},
				   		{"name": "Exercises", "page": 141, "children": []}
				   		]},
				   {"name": "Chapter 10: Traits", "page": 143, "children": [
				   		{"name": "10.1 Why No Multiple Inheritance?", "page": 144, "children": []},
				   		{"name": "10.2 Traits as Interfaces", "page": 146, "children": []},
				   		{"name": "10.3 Traits with Concrete Implementations", "page": 147, "children": []},
				   		{"name": "10.4 Objects with Traits", "page": 148, "children": []},
				   		{"name": "10.5 Layered Traits", "page": 148, "children": []},
				   		{"name": "10.6 Overriding Abstract Methods in Traits", "page": 150, "children": []},
				   		{"name": "10.7 Traits for Rich Interfaces", "page": 150, "children": []},
				   		{"name": "10.8 Concrete Fields in Traits", "page": 151, "children": []},
				   		{"name": "10.9 Abstract Fields in Traits", "page": 153, "children": []},
				   		{"name": "10.10 Trait Construction Order", "page": 153, "children": []},
				   		{"name": "10.11 Initializing Trait Fields", "page": 155, "children": []},
				   		{"name": "10.12 Traits Extending Classes", "page": 156, "children": []},
				   		{"name": "10.13 Self Types", "page": 157, "children": []},
				   		{"name": "10.14 What Happens under the Hood", "page": 158, "children": []},
				   		{"name": "Exercises", "page": 160, "children": []}
				   		]},
				   {"name": "Chapter 11: Operators", "page": 163, "children": [
				   		{"name": "11.1 Identifiers", "page": 165, "children": []},
				   		{"name": "11.2 Infix Operators", "page": 166, "children": []},
				   		{"name": "11.3 Unary Operators", "page": 166, "children": []},
				   		{"name": "11.4 Assignment Operators", "page": 167, "children": []},
				   		{"name": "11.5 Precedence", "page": 167, "children": []},
				   		{"name": "11.6 Associativity", "page": 168, "children": []},
				   		{"name": "11.7 The apply and update Methods", "page": 169, "children": []},
				   		{"name": "11.8 Extractors", "page": 170, "children": []},
				   		{"name": "11.9 Extractors with One or No Arguments", "page": 172, "children": []},
				   		{"name": "11.10 The unapplySeq Method", "page": 172, "children": []},
				   		{"name": "11.11 Dynamic Invocation", "page": 173, "children": []},
				   		{"name": "Exercises", "page": 176, "children": []}
				   		]},
				   {"name": "Chapter 12: Higher-Order Functions", "page": 179, "children": [
				   		{"name": "12.1 Functions as Values", "page": 180, "children": []},
				   		{"name": "12.2 Anonymous Functions", "page": 182, "children": []},
				   		{"name": "12.3 Functions with Function Parameters", "page": 183, "children": []},
				   		{"name": "12.4 Parameter Inference", "page": 183, "children": []},
				   		{"name": "12.5 Useful Higher-Order Functions", "page": 184, "children": []},
				   		{"name": "12.6 Closures", "page": 185, "children": []},
				   		{"name": "12.7 SAM Conversions", "page": 186, "children": []},
				   		{"name": "12.8 Currying", "page": 187, "children": []},
				   		{"name": "12.9 Control Abstractions", "page": 189, "children": []},
				   		{"name": "12.10 The return Expression", "page": 190, "children": []},
				   		{"name": "Exercises", "page": 191, "children": []}
				   		]},
				   {"name": "Chapter 13: Collections", "page": 193, "children": [
				   		{"name": "13.1 The Main Collections Traits", "page": 195, "children": []},
				   		{"name": "13.2 Mutable and Immutable Collections", "page": 196, "children": []},
				   		{"name": "13.3 Sequences", "page": 197, "children": []},
				   		{"name": "13.4 Lists", "page": 198, "children": []},
				   		{"name": "13.5 Sets", "page": 200, "children": []},
				   		{"name": "13.6 Operators for Adding or Removing Elements", "page": 201, "children": []},
				   		{"name": "13.7 Common Methods", "page": 203, "children": []},
				   		{"name": "13.8 Mapping a Function", "page": 205, "children": []},
				   		{"name": "13.9 Reducing, Folding, and Scanning", "page": 207, "children": []},
				   		{"name": "13.10 Zipping", "page": 210, "children": []},
				   		{"name": "13.11 Iterators", "page": 211, "children": []},
				   		{"name": "13.12 Streams", "page": 212, "children": []},
				   		{"name": "13.13 Lazy Views", "page": 213, "children": []},
				   		{"name": "13.14 Interoperability with Java Collections", "page": 214, "children": []},
				   		{"name": "13.15 Parallel Collections", "page": 216, "children": []},
				   		{"name": "Exercises", "page": 217, "children": []}
				   		]},
				   {"name": "Chapter 14: Pattern Matching and Case Classes", "page": 219, "children": [
				   		{"name": "14.1 A Better Switch", "page": 221, "children": []},
				   		{"name": "14.2 Guards", "page": 222, "children": []},
				   		{"name": "14.3 Variables in Patterns", "page": 222, "children": []},
				   		{"name": "14.4 Type Patterns", "page": 223, "children": []},
				   		{"name": "14.5 Matching Arrays, Lists, and Tuples", "page": 224, "children": []},
				   		{"name": "14.6 Extractors", "page": 225, "children": []},
				   		{"name": "14.7 Patterns in Variable Declarations", "page": 226, "children": []},
				   		{"name": "14.8 Patterns in for Expressions", "page": 227, "children": []},
				   		{"name": "14.9 Case Classes", "page": 228, "children": []},
				   		{"name": "14.10 The copy Method and Named Parameters", "page": 228, "children": []},
				   		{"name": "14.11 Infix Notation in case Clauses", "page": 229, "children": []},
				   		{"name": "14.12 Matching Nested Structures", "page": 230, "children": []},
				   		{"name": "14.13 Are Case Classes Evil?", "page": 231, "children": []},
				   		{"name": "14.14 Sealed Classes", "page": 232, "children": []},
				   		{"name": "14.15 Simulating Enumerations", "page": 232, "children": []},
				   		{"name": "14.16 The Option Type", "page": 233, "children": []},
				   		{"name": "14.17 Partial Functions", "page": 234, "children": []},
				   		{"name": "Exercises", "page": 235, "children": []}
				   		]},
				   {"name": "Chapter 15: Annotations", "page": 237, "children": [
				   		{"name": "15.1 What Are Annotations?", "page": 239, "children": []},
				   		{"name": "15.2 What Can Be Annotated?", "page": 239, "children": []},
				   		{"name": "15.3 Annotation Arguments", "page": 240, "children": []},
				   		{"name": "15.4 Annotation Implementations", "page": 241, "children": []},
				   		{"name": "15.5 Annotation for Java Features", "page": 242, "children": [
				   			{"name": "15.5.1 Java Modifiers", "page": 242, "children": []},
				   			{"name": "15.5.2 Marker Interfaces", "page": 243, "children": []},
				   			{"name": "15.5.3 Checked Exceptions", "page": 243, "children": []},
				   			{"name": "15.5.4 Variable Arguments", "page": 244, "children": []},
				   			{"name": "15.5.5 JavaBeans", "page": 244, "children": []}
				   			]},
				   		{"name": "15.6 Annotations for Optimizations", "page": 245, "children": [
				   			{"name": "15.6.1 Tail Recursion", "page": 245, "children": []},
				   			{"name": "15.6.2 Jump Table Generation and Inlining", "page": 246, "children": []},
				   			{"name": "15.6.3 Eliding Methods", "page": 247, "children": []},
				   			{"name": "15.6.4 Specialization for Primitive Types", "page": 248, "children": []}
				   			]},
				   		{"name": "15.7 Annotations for Errors and Warnings", "page": 249, "children": []},
				   		{"name": "Exercises", "page": 250, "children": []}
				   		]},
				   {"name": "Chapter 16: XML Processing", "page": 251, "children": [
				   		{"name": "16.1 XML Literals", "page": 253, "children": []},
				   		{"name": "16.2 XML Nodes", "page": 253, "children": []},
				   		{"name": "16.3 Element Attributes", "page": 255, "children": []},
				   		{"name": "16.4 Embedded Expressions", "page": 256, "children": []},
				   		{"name": "16.5 Expressions in Attributes", "page": 257, "children": []},
				   		{"name": "16.6 Uncommon Node Types", "page": 258, "children": []},
				   		{"name": "16.7 XPath-like Expressions", "page": 258, "children": []},
				   		{"name": "16.8 Pattern Matching", "page": 260, "children": []},
				   		{"name": "16.9 Modifying Elements and Attributes", "page": 261, "children": []},
				   		{"name": "16.10 Transforming XML", "page": 262, "children": []},
				   		{"name": "16.11 Loading and Saving", "page": 262, "children": []},
				   		{"name": "16.12 Namespaces", "page": 265, "children": []},
				   		{"name": "Exercises", "page": 266, "children": []}
				   		]},
				   {"name": "Chapter 17: Futures", "page": 269, "children": [
				   		{"name": "17.1 Running Tasks in the Future", "page": 271, "children": []},
				   		{"name": "17.2 Waiting for Results", "page": 273, "children": []},
				   		{"name": "17.3 The Try Class", "page": 274, "children": []},
				   		{"name": "17.4 Callbacks", "page": 274, "children": []},
				   		{"name": "17.5 Composing Future Tasks", "page": 275, "children": []},
				   		{"name": "17.6 Other Future Transformations", "page": 278, "children": []},
				   		{"name": "17.7 Methods in the Future Object", "page": 279, "children": []},
				   		{"name": "17.8 Promises", "page": 281, "children": []},
				   		{"name": "17.9 Execution Contexts", "page": 283, "children": []},
				   		{"name": "Exercises", "page": 283, "children": []}
				   		]},
				   {"name": "Chapter 18: Type Parameters", "page": 287, "children": [
				   		{"name": "18.1 Generic Classes", "page": 289, "children": []},
				   		{"name": "18.2 Generic Functions", "page": 289, "children": []},
				   		{"name": "18.3 Bounds for Type Variables", "page": 289, "children": []},
				   		{"name": "18.4 View Bounds", "page": 291, "children": []},
				   		{"name": "18.5 Context Bounds", "page": 291, "children": []},
				   		{"name": "18.6 The ClassTag Context Bound", "page": 292, "children": []},
				   		{"name": "18.7 Multiple Bounds", "page": 292, "children": []},
				   		{"name": "18.8 Type Constraints", "page": 292, "children": []},
				   		{"name": "18.9 Variance", "page": 294, "children": []},
				   		{"name": "18.10 Co- and Contravariant Positions", "page": 295, "children": []},
				   		{"name": "18.11 Objects Can't be Generic", "page": 297, "children": []},
				   		{"name": "18.12 Wildcards", "page": 298, "children": []},
				   		{"name": "Exercises", "page": 298, "children": []}
				   		]},
				    {"name": "Chapter 19: Advanced Types", "page": 301, "children": [
				   		{"name": "19.1 Singleton Types", "page": 303, "children": []},
				   		{"name": "19.2 Type Projections", "page": 304, "children": []},
				   		{"name": "19.3 Paths", "page": 305, "children": []},
				   		{"name": "19.4 Type Aliases", "page": 306, "children": []},
				   		{"name": "19.5 Structural Types", "page": 306, "children": []},
				   		{"name": "19.6 Compound Types", "page": 307, "children": []},
				   		{"name": "19.7 Infix Types", "page": 308, "children": []},
				   		{"name": "19.8 Existential Types", "page": 309, "children": []},
				   		{"name": "19.9 The Scala Type System", "page": 310, "children": []},
				   		{"name": "19.10 Self Types", "page": 311, "children": []},
				   		{"name": "19.11 Dependency Injection", "page": 312, "children": []},
				   		{"name": "19.12 Abstract Types", "page": 314, "children": []},
				   		{"name": "19.13 Family Polymorphism", "page": 316, "children": []},
				   		{"name": "19.14 Higher-Kinded Types", "page": 319, "children": []},
				   		{"name": "Exercises", "page": 322, "children": []}
				   		]},
				    {"name": "Chapter 20: Parsing", "page": 325, "children": [
				   		{"name": "20.1 Grammars", "page": 327, "children": []},
				   		{"name": "20.2 Combining Parser Operations", "page": 328, "children": []},
				   		{"name": "20.3 Transforming Parser Results", "page": 330, "children": []},
				   		{"name": "20.4 Discarding Tokens", "page": 331, "children": []},
				   		{"name": "20.5 Generating Parse Trees", "page": 332, "children": []},
				   		{"name": "20.6 Avoiding Left Recursion", "page": 333, "children": []},
				   		{"name": "20.7 More Combinators", "page": 334, "children": []},
				   		{"name": "20.8 Avoiding Backtracking", "page": 337, "children": []},
				   		{"name": "20.9 Packrat Parsers", "page": 337, "children": []},
				   		{"name": "20.10 What Exactly Are Parsers?", "page": 338, "children": []},
				   		{"name": "20.11 Regex Parsers", "page": 339, "children": []},
				   		{"name": "20.12 Token-Based Parsers", "page": 340, "children": []},
				   		{"name": "20.13 Error Handling", "page": 342, "children": []},
				   		{"name": "Exercises", "page": 343, "children": []}
				   		]},
				    {"name": "Chapter 21: Implicits", "page": 345, "children": [
				   		{"name": "21.1 Implicit Conversions", "page": 347, "children": []},
				   		{"name": "21.2 Using Implicits for Enriching Existing Classes", "page": 347, "children": []},
				   		{"name": "21.3 Importing Implicits", "page": 348, "children": []},
				   		{"name": "21.4 Rules for Implicit Conversions", "page": 349, "children": []},
				   		{"name": "21.5 Implicit Parameters", "page": 351, "children": []},
				   		{"name": "21.6 Implicit Conversions with Implicit Parameters", "page": 352, "children": []},
				   		{"name": "21.7 Context Bounds", "page": 352, "children": []},
				   		{"name": "21.8 Type Classes", "page": 354, "children": []},
				   		{"name": "21.9 Evidence", "page": 356, "children": []},
				   		{"name": "21.10 The @implicitNotFound Annotation", "page": 357, "children": []},
				   		{"name": "21.11 CanBuildFrom Demystified", "page": 357, "children": []},
				   		{"name": "Exercises", "page": 359, "children": []}
				   		]},
				    {"name": "Index", "page": 361, "children": []}
				 ]
}